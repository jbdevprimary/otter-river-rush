/**
 * SpriteLoader - Loads and caches PNG sprites generated by the sprite generator
 */

export class SpriteLoader {
  private sprites: Map<string, HTMLImageElement> = new Map();
  private loading: Map<string, Promise<HTMLImageElement>> = new Map();
  private basePath: string;

  constructor(basePath?: string) {
    // For local dev, sprites are at /sprites/
    // For production, this can be overridden
    this.basePath = basePath || `${import.meta.env.BASE_URL}sprites/`;
  }

  /**
   * Load a sprite by filename
   */
  public async load(filename: string): Promise<HTMLImageElement> {
    // Return cached sprite if available
    if (this.sprites.has(filename)) {
      return this.sprites.get(filename)!;
    }

    // Return ongoing load promise if loading
    if (this.loading.has(filename)) {
      return this.loading.get(filename)!;
    }

    // Start loading
    const loadPromise = this.loadImage(filename);
    this.loading.set(filename, loadPromise);

    try {
      const img = await loadPromise;
      this.sprites.set(filename, img);
      this.loading.delete(filename);
      return img;
    } catch (error) {
      this.loading.delete(filename);
      throw error;
    }
  }

  /**
   * Load multiple sprites at once
   */
  public async loadBatch(filenames: string[]): Promise<HTMLImageElement[]> {
    return Promise.all(filenames.map((f) => this.load(f)));
  }

  /**
   * Preload all game sprites
   */
  public async preloadAll(): Promise<void> {
    const spriteFiles = [
      // Characters
      'otter.png',
      'otter-shield.png',

      // Obstacles
      'rock-1.png',
      'rock-2.png',
      'rock-3.png',

      // Collectibles
      'coin.png',
      'gem-blue.png',
      'gem-red.png',

      // Power-ups
      'powerup-shield.png',
      'powerup-speed.png',
      'powerup-multiplier.png',
      'powerup-magnet.png',

      // Effects
      'water-ripple.png',
      'splash.png',
    ];

    // Preloading sprites...
    const start = performance.now();

    await this.loadBatch(spriteFiles);

    const duration = Math.round(performance.now() - start);
    // Sprites loaded
    if (duration > 1000) {
      console.warn(`Slow sprite loading: ${duration}ms`);
    }
  }

  /**
   * Get a cached sprite (must be loaded first)
   */
  public get(filename: string): HTMLImageElement | null {
    return this.sprites.get(filename) || null;
  }

  /**
   * Check if sprite is loaded
   */
  public has(filename: string): boolean {
    return this.sprites.has(filename);
  }

  /**
   * Get loading progress (0-1)
   */
  public getProgress(): number {
    const total = 14; // Total sprites we expect
    const loaded = this.sprites.size;
    return Math.min(loaded / total, 1);
  }

  /**
   * Clear all cached sprites
   */
  public clear(): void {
    this.sprites.clear();
    this.loading.clear();
  }

  /**
   * Internal: Load single image
   */
  private loadImage(filename: string): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();

      img.onload = () => resolve(img);
      img.onerror = () => {
        reject(new Error(`Failed to load sprite: ${filename}`));
      };

      img.src = this.basePath + filename;
    });
  }

  /**
   * Draw sprite with optional transformations
   */
  public draw(
    ctx: CanvasRenderingContext2D,
    filename: string,
    x: number,
    y: number,
    width?: number,
    height?: number,
    options?: {
      rotation?: number;
      alpha?: number;
      flipX?: boolean;
      flipY?: boolean;
    }
  ): void {
    const sprite = this.get(filename);
    if (!sprite) {
      console.warn(`Sprite not loaded: ${filename}`);
      return;
    }

    ctx.save();

    // Apply transformations
    if (options?.alpha !== undefined) {
      ctx.globalAlpha = options.alpha;
    }

    // Center point for rotation
    const centerX = x + (width || sprite.width) / 2;
    const centerY = y + (height || sprite.height) / 2;

    ctx.translate(centerX, centerY);

    if (options?.rotation) {
      ctx.rotate(options.rotation);
    }

    // Handle flipping
    const scaleX = options?.flipX ? -1 : 1;
    const scaleY = options?.flipY ? -1 : 1;
    if (scaleX !== 1 || scaleY !== 1) {
      ctx.scale(scaleX, scaleY);
    }

    // Draw sprite centered
    const drawWidth = width || sprite.width;
    const drawHeight = height || sprite.height;

    ctx.drawImage(
      sprite,
      -drawWidth / 2,
      -drawHeight / 2,
      drawWidth,
      drawHeight
    );

    ctx.restore();
  }

  /**
   * Draw sprite with source rectangle (for sprite sheets)
   */
  public drawRegion(
    ctx: CanvasRenderingContext2D,
    filename: string,
    sx: number,
    sy: number,
    sWidth: number,
    sHeight: number,
    dx: number,
    dy: number,
    dWidth: number,
    dHeight: number
  ): void {
    const sprite = this.get(filename);
    if (!sprite) return;

    ctx.drawImage(sprite, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
  }
}

// Singleton instance
export const spriteLoader = new SpriteLoader();
